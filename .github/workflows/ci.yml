# This is a GitHub Actions workflow file. It defines a series of automated jobs
# that run in response to events in your repository, such as pushes or pull requests.
# This workflow specifically handles Continuous Integration (CI) for your Django project.

name: Django CI

# Controls when the workflow will run.
# It triggers on pushes to any branch and on pull requests targeting the main branch.
on:
  push:
    branches: [ "**" ]
  pull_request:
    branches: [ "main" ]

jobs:
  # The 'build' job contains all the steps for linting and testing.
  build:
    # The type of runner that the job will run on. We use the latest Ubuntu.
    runs-on: ubuntu-latest

    # Services to spin up as Docker containers for the duration of the job.
    # We need a PostgreSQL database and a Redis cache for our tests.
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: ${{ secrets.DATABASE_NAME || 'test_db' }}
          POSTGRES_USER: ${{ secrets.DATABASE_USER || 'test_user' }}
          POSTGRES_PASSWORD: ${{ secrets.DATABASE_PASSWORD || 'test_pass' }}
        ports:
          - 5432:5432
        # Health check to wait until postgres is ready
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:6
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    # A sequence of tasks that will be executed as part of the job.
    steps:
    # Step 1: Check out the repository code so the workflow can access it.
    - name: Checkout repository
      uses: actions/checkout@v4

    # Step 2: Set up the specific version of Python we want to use.
    - name: Set up Python 3.12
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"
        cache: 'pip' # Cache pip dependencies to speed up subsequent runs

    # Step 3: Install the Python dependencies listed in requirements.txt.
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    # Step 4: Run the linter to check for code style issues.
    # The --ignore=E501 flag tells flake8 to not complain about lines longer than 79 chars,
    # as the 'black' formatter handles line length automatically.
    - name: Lint with flake8
      run: |
        # With a .flake8 file, you just need to run the command.
        # All configuration is loaded automatically.
        flake8 .

    # Step 5: Run the Django tests.
    # We provide the necessary environment variables to the command, referencing the
    # service containers we defined above.
    - name: Run Tests
      env:
        # Use the credentials defined in the services block.
        # For the hosts, 'localhost' works because of the port mapping.
        DATABASE_NAME: ${{ secrets.DATABASE_NAME || 'test_db' }}
        DATABASE_USER: ${{ secrets.DATABASE_USER || 'test_user' }}
        DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD || 'test_pass' }}
        WRITER_DB_HOST: localhost
        READER_DB_HOST: localhost
        DATABASE_PORT: 5432
        REDIS_HOST: localhost
        REDIS_PORT: 6379
      run: |
        coverage run manage.py test
        coverage report
